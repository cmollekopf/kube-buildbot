# -*- python -*-
# ex: set filetype=python:


from buildbot import config
from buildbot.plugins import *
from buildbot.plugins import util
from buildbot.process import buildstep, logobserver, results
from buildbot.process.results import worst_status

import re
from future.utils import string_types, itervalues
from twisted.internet import defer
from twisted.python import log

import config
import benchmarkdashboard
import os

def findLogfile(logfile):
    return os.path.realpath(os.path.expanduser('~/kdebuild/kube/source/log/latest/' + logfile)).replace('/work/', os.path.expanduser('~/kdebuild/kube/'))

#Buildsteps
class KubeBuildStep(buildstep.ShellMixin, buildstep.BuildStep):

    progressMetrics = ('output',)
    logfiles = {}
    bufferLogObserver = None

    def __init__(self, **kwargs):
        kwargs = self.setupShellMixin(kwargs, prohibitArgs=['command'])
        buildstep.BuildStep.__init__(self, **kwargs)
        self.addLogObserver('stdio', logobserver.OutputProgressObserver("output"))
        self.bufferLogObserver = logobserver.BufferLogObserver()
        self.addLogObserver('stdio', self.bufferLogObserver)

    def evaluateCommand(self, cmd):
        regexes = ((re.compile("FAILED"), results.FAILURE), (re.compile("WARNING"), results.WARNINGS))
        worst = cmd.results()
        for err, possible_status in regexes:
            # worst_status returns the worse of the two status' passed to it.
            # we won't be changing "worst" unless possible_status is worse than it,
            # so we don't even need to check the log if that's the case
            if worst_status(worst, possible_status) == possible_status:
                if err.search(self.bufferLogObserver.getStdout()):
                    worst = possible_status
        return worst

    @defer.inlineCallbacks
    def run(self):
        cmd = yield self.makeRemoteShellCommand(
            command="{}/testenv.py srcbuild --noninteractive kube kdesrcbuild --stop-after=Kube --verbose".format(config.dockerdir),
            collectStdout=True
        )
        yield self.runCommand(cmd)
        defer.returnValue(self.evaluateCommand(cmd))

    def setProgress(self, metric, value):
        log.msg("Progress %s %s"% (metric, value))
        self.updateSummary()

    def getResultSummary(self):
        stepsumm = u'finished'
        if self.results != results.SUCCESS:
            stepsumm += u' (%s)' % results.Results[self.results]
        return {u'step': stepsumm}

    def getCurrentSummary(self):
        return {u'step': u'running'}

class CollectLogFiles(buildstep.ShellMixin, buildstep.BuildStep):

    def __init__(self, **kwargs):
        kwargs = self.setupShellMixin(kwargs, prohibitArgs=['command'])
        buildstep.BuildStep.__init__(self, **kwargs)

    @defer.inlineCallbacks
    def run(self):
        self.logfiles = {"sinkbuild": findLogfile('Sink/build.log'),
                "sinkcmake": findLogfile('Sink/cmake.log'),
                "kubebuild": findLogfile('Kube/build.log'),
                "kubecmake": findLogfile('Kube/cmake.log')}
        log.msg("Collecting logfiles: %s" % self.logfiles)
        #Because the LogFileWatcher only takes output from changed files we have to go and touch them all.
        cmd = yield self.makeRemoteShellCommand(
            command="touch %s; touch %s; touch %s; touch %s" % (findLogfile('Sink/build.log'), findLogfile('Sink/cmake.log'), findLogfile('Kube/build.log'), findLogfile('Kube/cmake.log')),
            logfiles=self.logfiles
        )
        yield self.runCommand(cmd)
        defer.returnValue(cmd.results())

class DockerCTestStep(buildstep.ShellMixin, buildstep.BuildStep):
    logfiles = {}
    bufferLogObserver = None
    command = None
    regexes = None

    def __init__(self, command, regexes, **kwargs):
        kwargs = self.setupShellMixin(kwargs, prohibitArgs=['command'])
        buildstep.BuildStep.__init__(self, **kwargs)
        self.bufferLogObserver = logobserver.BufferLogObserver()
        self.addLogObserver('stdio', self.bufferLogObserver)
        self.command = command
        self.regexes = regexes

    def evaluateCommand(self, cmd):
        worst = cmd.results()
        for err, possible_status in self.regexes:
            # worst_status returns the worse of the two status' passed to it.
            # we won't be changing "worst" unless possible_status is worse than it,
            # so we don't even need to check the log if that's the case
            if worst_status(worst, possible_status) == possible_status:
                if err.search(self.bufferLogObserver.getStdout()):
                    worst = possible_status
        return worst

    @defer.inlineCallbacks
    def run(self):
        cmd = yield self.makeRemoteShellCommand(
            command=self.command,
            collectStdout=True
        )
        yield self.runCommand(cmd)
        defer.returnValue(self.evaluateCommand(cmd))



# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['buildbotNetUsageData'] = None
####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [
    # worker.Worker("example-worker", "pass"),
    worker.LocalWorker('local1'),
    worker.LocalWorker('local2'),
]
# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

c['change_source'] = []
#For "buildbot sendchange"
c['change_source'].append(changes.PBChangeSource(port=9999, user='user', passwd='userpw'))

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.
c['builders'] = []

dockerenv = {
    "PYTHONPATH": config.dockerdir,
    "PATH": "/usr/bin:${PATH}"
}
workerpool = ["local1", "local2"]

def addBuilder(builder):
    c['builders'].append(builder)


def kubeBuildFactory(buildConfigName, buildConfig):
    f = util.BuildFactory()

    hostSourceDir="~/kdebuild/kube/source"
    hostBuildDir="~/kdebuild/kube/{}/build".format(buildConfigName)
    hostInstallDir="~/kdebuild/kube/{}/install".format(buildConfigName)

    def dockerCmd(cmd, workdir, haltOnFailure=True):
        def runInDocker(cmd, workdir):
            return "docker run --rm -v {sourcedir}:/src -v {builddir}:/build -v {installdir}:/install -w {workdir} kubedev -c '{cmd}'".format(
                    workdir=workdir,
                    sourcedir=hostSourceDir,
                    builddir=hostBuildDir,
                    installdir=hostInstallDir,
                    cmd=cmd)
        return util.ShellArg(command = runInDocker(cmd, workdir), logfile='output', haltOnFailure=haltOnFailure)

    def buildRepositoryBuildsteps(repositoryName):
        sourcedir="/src/{}".format(repositoryName)
        builddir="/build/{}".format(repositoryName)

        cmake_options="-DCMAKE_PREFIX_PATH=/install -DCMAKE_INSTALL_PREFIX=/install -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_BUILD_TYPE=debug -DCMAKE_C_COMPILER=/usr/bin/clang -DCMAKE_CXX_COMPILER=/usr/bin/clang++"
        return steps.ShellSequence(name = repositoryName,
            commands = [
                dockerCmd("mkdir -p {}".format(builddir), "/"),
                dockerCmd("cmake {options} {sourcedir}".format(options=cmake_options, sourcedir=sourcedir), builddir),
                dockerCmd("make && make install", builddir),
            ],
            haltOnFailure=True
            )

    def prepareBuildsteps():
        prepareSteps = [
            util.ShellArg(
                command = 'mkdir -p {};'.format(hostBuildDir)
                        + 'mkdir -p {};'.format(hostInstallDir),
                logfile='output',
                haltOnFailure=True),
        ]
        if buildConfig['cleanbuild']:
            prepareSteps.append(
                util.ShellArg(
                    command = 'rm -Rf {}/*;'.format(hostBuildDir)
                            + 'rm -Rf {}/*;'.format(hostInstallDir),
                    logfile='output',
                    haltOnFailure=True))
        return steps.ShellSequence(name = 'prepare',
            commands = prepareSteps,
            haltOnFailure=True
            )


    f.addStep(steps.Git(repourl='git://anongit.kde.org/kube', branch='develop'))
    f.addStep(steps.ShellSequence(name = 'buildDockerImage',
        commands = [
            util.ShellArg(
                command = 'docker build -t kubedev .',
                logfile = 'output',
                haltOnFailure=True)
        ],
        workdir = 'build/docker',
        haltOnFailure=True
        ))
    f.addStep(prepareBuildsteps())
    f.addStep(buildRepository('flatbuffers'))
    f.addStep(buildRepository('kasync'))
    f.addStep(buildRepository('kdav2'))
    f.addStep(buildRepository('kimap2'))
    f.addStep(buildRepository('Sink'))
    f.addStep(buildRepository('Kube'))

    return util.BuilderConfig(name=buildConfigName, workernames=workerpool, factory=f)


def setupBuilds():
    builds = {
        'debugbuild': {'cleanbuild': False}
    }

    for name, buildConfig in builds.iteritems():
        addBuilder(kubeBuildFactory(name, buildConfig))

setupBuilds()

def buildkube():
    f = util.BuildFactory()
    f.addStep(KubeBuildStep(env=dockerenv))
    f.addStep(CollectLogFiles())
    return util.BuilderConfig(name="buildkube", workernames=workerpool, factory=f)

addBuilder(buildkube())

def testkube():
    f = util.BuildFactory()
    f.addStep(DockerCTestStep(
        command="{}/testenv.py srcbuild --imap --noninteractive kube Sink ctest -V".format(config.dockerdir),
        regexes=((re.compile("FAILED"), results.FAILURE), ),
        env=dockerenv)
    )
    f.addStep(DockerCTestStep(
        command="{}/testenv.py srcbuild --x11forward --noninteractive kube Kube ctest -V".format(config.dockerdir),
        regexes=((re.compile("FAILED"), results.FAILURE), ),
        env=dockerenv)
    )
    return util.BuilderConfig(name="testkube", workernames=workerpool, factory=f)

addBuilder(testkube())

def benchmarkkube():
    f = util.BuildFactory()
    f.addStep(steps.ShellCommand(
        command="{}/testenv.py srcbuild --noninteractive kube Sink tests/mailquerybenchmark".format(config.dockerdir),
        env=dockerenv)
    )
    f.addStep(steps.ShellCommand(
        command="{}/testenv.py srcbuild --noninteractive kube Sink tests/dummyresourcewritebenchmark".format(config.dockerdir),
        env=dockerenv)
    )
    f.addStep(steps.ShellCommand(
        command="{}/testenv.py srcbuild --noninteractive kube Sink tests/dummyresourcebenchmark".format(config.dockerdir),
        env=dockerenv)
    )
    f.addStep(steps.ShellCommand(
        command="{}/testenv.py srcbuild --noninteractive kube Sink tests/storagebenchmark".format(config.dockerdir),
        env=dockerenv)
    )
    f.addStep(steps.ShellCommand(
        command="{}/testenv.py srcbuild --noninteractive kube Sink tests/pipelinebenchmark".format(config.dockerdir),
        env=dockerenv)
    )
    return util.BuilderConfig(name="benchmarkkube", workernames=workerpool, factory=f)

addBuilder(benchmarkkube())

def kolabnowflatpak():
    f = util.BuildFactory()
    f.addStep(
        steps.ShellCommand(command="{}/rebuildkolabnow.sh".format(config.flatpakdir))
    )
    f.addStep(
        steps.ShellCommand(command="{}/uploadkolabnow.sh".format(config.flatpakdir))
    )
    return util.BuilderConfig(name="kolabnowflatpak", workernames=workerpool, factory=f)

addBuilder(kolabnowflatpak())

def nightlyflatpak():
    f = util.BuildFactory()
    f.addStep(
        steps.ShellCommand(command="{}/rebuildkolab.sh".format(config.flatpakdir))
    )
    f.addStep(
        steps.ShellCommand(command="{}/uploadkolab.sh".format(config.flatpakdir))
    )
    return util.BuilderConfig(name="nightlyflatpak", workernames=workerpool, factory=f)

addBuilder(nightlyflatpak())


####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

c['schedulers'] = []

c['schedulers'].append(schedulers.SingleBranchScheduler(
                            name="all",
                            change_filter=util.ChangeFilter(branch='develop'),
                            treeStableTimer=None,
                            builderNames=["buildkube", "testkube"]))

c['schedulers'].append(schedulers.ForceScheduler(
                            name="force",
                            builderNames = [b.name for b in c['builders']]))

c['schedulers'].append(schedulers.Try_Userpass(
                                    name='try',
                                    builderNames=['buildkube', 'testkube'],
                                    port=5555,
                                    userpass=[('user','userpw')]))

# Build and run tests at 2 o'clock
nightlyRebuildScheduler = schedulers.Nightly(name='nightly-rebuild',
                                    builderNames=['buildkube'],
                                    hour=2, minute=0)
c['schedulers'].append(nightlyRebuildScheduler)
nightlyTestScheduler = schedulers.Dependent(name='test-rebuild',
                                            upstream=nightlyRebuildScheduler,
                                            builderNames=['testkube'])
c['schedulers'].append(nightlyTestScheduler)
# Build a nightly flatpak if the test pass
c['schedulers'].append(schedulers.Dependent(name='nightly-flatpak',
                                            upstream=nightlyTestScheduler,
                                            builderNames=['nightlyflatpak']))

#Run benchmarks ever night at 3 o'clock (let's hope the system isn't busy at that point)
c['schedulers'].append(schedulers.Nightly(name='nightly-benchmark',
                                    builderNames=['benchmarkkube'],
                                    hour=3, minute=0))


####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.
c['services'] = []
c['services'].append(reporters.IRC(host="chat.freenode.net", nick="bbkube", channels=["#kube"], port=6665))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Kube CI"
# c['titleURL'] = "https://buildbot.github.io/hello-world/"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://localhost:8010/"

# minimalistic config to activate new web UI
c['www'] = dict(port=8010,
                plugins=dict(waterfall_view={}, console_view={}, grid_view={}))
# Custom dashboard
c['www']['plugins']['wsgi_dashboards'] = [  # This is a list of dashboards, you can create several
    {
        'name': 'benchmarks',  # as used in URLs
        'caption': 'Benchmarks',  # Title displayed in the UI'
        'app': benchmarkdashboard.benchmarkdashboard,
        # priority of the dashboard in the left menu (lower is higher in the
        # menu)
        'order': 5,
        # available icon list can be found at http://fontawesome.io/icons/
        'icon': 'area-chart'
    }
]

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
