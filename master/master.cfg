# -*- python -*-
# ex: set filetype=python:


from buildbot import config
from buildbot.plugins import *
from buildbot.plugins import util
from buildbot.process import buildstep, logobserver, results
from buildbot.process.results import worst_status

import re
from future.utils import string_types, itervalues
from twisted.internet import defer
from twisted.python import log

import config
import benchmarkdashboard
import os

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['buildbotNetUsageData'] = None
####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.

def createWorkerPool():
    workerpool = ["local1", "local2"]
    c['workers'] = []
    for workername in workerpool:
        c['workers'].append(worker.LocalWorker(workername))
    return workerpool

workerpool = createWorkerPool()

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

c['change_source'] = []
#For "buildbot sendchange"
c['change_source'].append(changes.PBChangeSource(port=9999, user='user', passwd='userpw'))

c['change_source'] = changes.GitPoller(repourl='git://anongit.kde.org/sink', branches=['master', 'develop'])
c['change_source'] = changes.GitPoller(repourl='git://anongit.kde.org/kube', branches=['master', 'develop'])

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.
c['builders'] = []

def addBuilder(builder):
    c['builders'].append(builder)

def kubeBuildFactory(buildConfigName, buildConfig):
    f = util.BuildFactory()

    hostSourceDir=buildConfig['sourcedir']
    hostBuildDir=buildConfig['builddir']
    hostInstallDir=buildConfig['installdir']

    def dockerCommand(cmd, workdir, extra_args=""):
        return "docker run --rm {extra_args} -v {sourcedir}:/src -v {builddir}:/build -v {installdir}:/install -w {workdir} kubedev bash -c '{cmd}'".format(
                extra_args=extra_args,
                workdir=workdir,
                sourcedir=hostSourceDir,
                builddir=hostBuildDir,
                installdir=hostInstallDir,
                cmd=cmd)

    def dockerCmd(cmd, workdir, haltOnFailure=True):
        return util.ShellArg(command = dockerCommand(cmd, workdir), logfile='output', haltOnFailure=haltOnFailure)

    def prepareBuildsteps():
        prepareSteps = [
            util.ShellArg(
                command = 'mkdir -p {};'.format(hostBuildDir)
                        + 'mkdir -p {};'.format(hostInstallDir),
                logfile='output',
                haltOnFailure=True),
        ]
        if buildConfig['cleanbuild']:
            prepareSteps.append(
                util.ShellArg(
                    command = 'rm -Rf {}/*;'.format(hostBuildDir)
                            + 'rm -Rf {}/*;'.format(hostInstallDir),
                    logfile='output',
                    haltOnFailure=True))
        return steps.ShellSequence(name = 'prepare',
            commands = prepareSteps,
            haltOnFailure=True
            )


    f.addStep(steps.Git(repourl='git://anongit.kde.org/kube', branch='develop'))
    f.addStep(steps.ShellSequence(name = 'buildDockerImage',
        commands = [
            util.ShellArg(
                command = 'docker build -t kubedev .',
                logfile = 'output',
                haltOnFailure=True)
        ],
        workdir = 'build/docker',
        haltOnFailure=True
        ))
    docker_options_x11 = '-t --security-opt seccomp:unconfined -v /tmp/.docker.xauth:/tmp/.docker.xauth -v /tmp/.X11-unix:/tmp/.X11-unix --device /dev/dri/card0:/dev/dri/card0 -e DISPLAY=:0 -e XAUTHORITY=/tmp/.docker.xauth'
    f.addStep(prepareBuildsteps())

    #Setup buildsteps for all repos
    for repo in buildConfig['repos']:
        sourcedir="/src/{}".format(repo['name'])
        builddir="/build/{}".format(repo['name'])
        f.addStep(steps.ShellSequence(name = repo['name'],
            commands = [
                dockerCmd("mkdir -p {}".format(builddir), "/"),
                dockerCmd("cmake {options} {sourcedir}".format(options=repo['cmake'], sourcedir=sourcedir), builddir)
            ],
            haltOnFailure=True
            ))
        f.addStep(steps.Compile(name = "compile {}".format(repo['name']),
            command=dockerCommand("make -j `nproc` && make install", builddir)
            ))

    if 'tests' in buildConfig:
        for test in buildConfig['tests']:
            name = "{}: {}".format(test['workdir'], test['command'])
            timeout = 1200
            if 'timeout' in test:
                timeout = test['timeout']
            f.addStep(steps.Test(name=name, command=dockerCommand(test['command'], test['workdir'], docker_options_x11), timeout=timeout))

    return util.BuilderConfig(name=buildConfigName, workernames=workerpool, factory=f)


def setupBuilds():
    cmake_options="-DCMAKE_PREFIX_PATH=/install -DCMAKE_INSTALL_PREFIX=/install -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_C_COMPILER=/usr/bin/clang -DCMAKE_CXX_COMPILER=/usr/bin/clang++"
    debug_cmake_options = cmake_options + ' -DCMAKE_BUILD_TYPE=debug'
    release_cmake_options = cmake_options + ' -DCMAKE_BUILD_TYPE=release'
    asan_options = "ASAN_OPTIONS=detect_odr_violation=0,symbolize=1,fast_unwind_on_malloc=0,check_initialization_order=1,detect_deadlocks=1"
    lsan_options = "LSAN_OPTIONS=suppressions=/src/sink/suppressions.lsan"
    builds = {
        'debugbuild': {'cleanbuild': False,
                       'sourcedir': "~/src",
                       'builddir': "~/src/debug/build",
                       'installdir': "~/src/debug/install",
                       'repos': [{'name': 'flatbuffers', 'cmake': debug_cmake_options},
                                 {'name': 'kasync', 'cmake': debug_cmake_options},
                                 {'name': 'kdav2', 'cmake': debug_cmake_options},
                                 {'name': 'kimap2', 'cmake': debug_cmake_options},
                                 {'name': 'sink', 'cmake': debug_cmake_options + ' -DENABLE_MEMCHECK=OFF -DCATCH_ERRORS=ON'},
                                 {'name': 'kube', 'cmake': debug_cmake_options},
                       ],
                       'tests': [
                           {'command': '/home/developer/startimap.sh && ctest -V', 'workdir': '/build/sink'},
                           {'command': 'ctest -V', 'workdir': '/build/kube'}
                       ]
        },
        'debugbuild-loadtest': {'cleanbuild': False,
                       'sourcedir': "~/src",
                       'builddir': "~/src/debug/build",
                       'installdir': "~/src/debug/install",
                       'repos': [],
                       'tests': [
                           {'command': 'tests/sinkloadtest.py', 'workdir': '/src/sink', 'timeout': 35 * 60}
                       ]
        },
        'releasebuild': {'cleanbuild': False,
                         'sourcedir': "~/src",
                         'builddir': "~/src/release/build",
                         'installdir': "~/src/release/install",
                         'repos': [{'name': 'flatbuffers', 'cmake': release_cmake_options},
                                    {'name': 'kasync', 'cmake': release_cmake_options},
                                    {'name': 'kdav2', 'cmake': release_cmake_options},
                                    {'name': 'kimap2', 'cmake': release_cmake_options},
                                    {'name': 'sink', 'cmake': release_cmake_options},
                                    {'name': 'kube', 'cmake': release_cmake_options},
                         ]
        },
        'asanbuild': {'cleanbuild': False,
                      'sourcedir': "~/src",
                      'builddir': "~/src/asan/build",
                      'installdir': "~/src/asan/install",
                      'repos': [{'name': 'flatbuffers', 'cmake': debug_cmake_options},
                                 {'name': 'kasync', 'cmake': debug_cmake_options},
                                 {'name': 'kdav2', 'cmake': debug_cmake_options},
                                 {'name': 'kimap2', 'cmake': debug_cmake_options},
                                 {'name': 'sink', 'cmake': debug_cmake_options + ' -DENABLE_ASAN=TRUE -DENABLE_MEMCHECK=OFF'}
                      ],
                      'tests': [
                           {'command': "{} {} /home/developer/startimap.sh && ctest -E \"modelinteractivity*\" -V".format(asan_options, lsan_options), 'workdir': '/build/sink'}
                      ]
        }
    }

    for name, buildConfig in builds.items():
        addBuilder(kubeBuildFactory(name, buildConfig))

setupBuilds()

def benchmarkkube():
    hostSourceDir="~/src"
    hostBuildDir="~/src/debug/build"
    hostInstallDir="~/src/debug/install"
    hawdDir="~/hawd"

    def dockerCommand(cmd, workdir, extra_args=""):
        return "docker run --rm {extra_args} -v {hawdDir}:/home/developer/hawd -v {srcdir}:/src -v {builddir}:/build -v {installdir}:/install -w {workdir} kubedev bash -c '{cmd}'".format(
                extra_args=extra_args,
                workdir=workdir,
                srcdir=hostSourceDir,
                builddir=hostBuildDir,
                installdir=hostInstallDir,
                hawdDir=hawdDir,
                cmd=cmd)

    f = util.BuildFactory()

    def addSinkBenchmark(cmd):
        f.addStep(steps.ShellCommand(name=cmd, command=dockerCommand(cmd, '/build/sink')))

    addSinkBenchmark('tests/mailquerybenchmark')
    addSinkBenchmark('tests/dummyresourcebenchmark')
    addSinkBenchmark('tests/dummyresourcewritebenchmark')
    addSinkBenchmark('tests/dummyresourcebenchmark')
    addSinkBenchmark('tests/storagebenchmark')
    addSinkBenchmark('tests/pipelinebenchmark')
    addSinkBenchmark('examples/imapresource/tests/imapmailsyncbenchmark')
    # addSinkBenchmark('tests/databasepopulationandfacadequerybenchmark')

    return util.BuilderConfig(name="benchmarkkube", workernames=workerpool, factory=f)

addBuilder(benchmarkkube())

def kolabnowflatpak():
    f = util.BuildFactory()
    f.addStep(
        steps.ShellCommand(command="{}/rebuildkolabnow.sh".format(config.flatpakdir))
    )
    f.addStep(
        steps.ShellCommand(command="{}/uploadkolabnow.sh".format(config.flatpakdir))
    )
    return util.BuilderConfig(name="kolabnowflatpak", workernames=workerpool, factory=f)

addBuilder(kolabnowflatpak())

def nightlyflatpak():
    f = util.BuildFactory()
    f.addStep(
        steps.ShellCommand(command="{}/rebuildkolab.sh".format(config.flatpakdir))
    )
    f.addStep(
        steps.ShellCommand(command="{}/uploadkolab.sh".format(config.flatpakdir))
    )
    return util.BuilderConfig(name="nightlyflatpak", workernames=workerpool, factory=f)

addBuilder(nightlyflatpak())


####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

c['schedulers'] = []

#Trigger a rebuild when the sources change
c['schedulers'].append(schedulers.SingleBranchScheduler(
                            name='all',
                            change_filter=util.ChangeFilter(branch=['master', 'develop']),
                            treeStableTimer=60,
                            builderNames = [b.name for b in c['builders']]))

c['schedulers'].append(schedulers.ForceScheduler(
                            name="force",
                            builderNames = [b.name for b in c['builders']]))


# Build and run tests at 2 o'clock
nightlyRebuildScheduler = schedulers.Nightly(name='nightly-rebuild',
                                    builderNames=['debugbuild', 'releasebuild', 'asanbuild'],
                                    hour=2, minute=0)
c['schedulers'].append(nightlyRebuildScheduler)
# Build a nightly flatpak if the test pass
c['schedulers'].append(schedulers.Dependent(name='nightly-flatpak',
                                            upstream=nightlyRebuildScheduler,
                                            builderNames=['nightlyflatpak']))

#Run benchmarks ever night at 3 o'clock (let's hope the system isn't busy at that point)
c['schedulers'].append(schedulers.Nightly(name='nightly-benchmark',
                                    builderNames=['benchmarkkube'],
                                    hour=3, minute=0))

c['schedulers'].append(schedulers.Nightly(name='nightly-loadtest',
                                    builderNames=['debugbuild-loadtest'],
                                    hour=4, minute=0))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.
c['services'] = []
c['services'].append(reporters.IRC(host="chat.freenode.net", nick="bbkube", channels=["#kube"], port=6665))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Kube CI"
# c['titleURL'] = "https://buildbot.github.io/hello-world/"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://localhost:8010/"

# minimalistic config to activate new web UI
c['www'] = dict(port=8010,
                plugins=dict(waterfall_view={}, console_view={}, grid_view={}))
# Custom dashboard
c['www']['plugins']['wsgi_dashboards'] = [  # This is a list of dashboards, you can create several
    {
        'name': 'benchmarks',  # as used in URLs
        'caption': 'Benchmarks',  # Title displayed in the UI'
        'app': benchmarkdashboard.benchmarkdashboard,
        # priority of the dashboard in the left menu (lower is higher in the
        # menu)
        'order': 5,
        # available icon list can be found at http://fontawesome.io/icons/
        'icon': 'area-chart'
    }
]

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
